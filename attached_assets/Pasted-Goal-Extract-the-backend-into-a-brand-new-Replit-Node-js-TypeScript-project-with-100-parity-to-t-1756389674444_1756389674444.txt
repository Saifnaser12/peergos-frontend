Goal: Extract the backend into a brand-new Replit Node.js (TypeScript) project with 100% parity to the current monorepo backend. No omissions. Deliver a PARITY_REPORT.md proving that all features, endpoints, models, migrations, seeds (including full UAE Chart of Accounts), background jobs, notifications, auth flows, and environment/configs are included and working. If any parity check fails, stop, fix, and re-run until GREEN.
0) Create clean project
New Replit project: Node.js template. Name it peergos-backend-prod.
Use CommonJS by default ("type":"commonjs"); keep esModuleInterop:true. Only switch to ESM if required and then standardize.
1) Bring over backend ONLY (no frontend code)
Copy from the main system all backend code and assets, including:
src/ (controllers, services, routes, middleware, validators, utils)
src/config/ (env, security, cors, rate limiting)
src/db/ (ORM config, migrations, seeders, fixtures)
src/tax/ (VAT 5%, CIT 9%, free-zone/QFZP logic, small business relief)
src/workflows/fta/* (FTA workflows, submission preps)
src/notifications/ (real-time/webhooks/email push)
src/auth/ (sessions/JWT/cookies, role/permission middleware)
src/background/ (cron/queues/jobs)
src/integrations/ (G42, Injazat placeholders, POS/bank placeholders)
Static resources required by backend (e.g., JSON dictionaries, i18n needed server-side)
Scripts: all migrations & all seeders, including UAE Chart of Accounts (full dataset)
OpenAPI/Swagger docs or route docs if present
Any feature flags/config files
Exclude React/Vite/Expo/Tailwind/Shadcn files.
2) Project scaffolding
Create these at repo root:
package.json (scripts below)
tsconfig.json (compiler options below)
.env.example (all keys used)
README.md
MANIFEST.json (built later)
PARITY_REPORT.md (built later)
package.json (scripts)
{
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/server.js",
    "typecheck": "tsc --noEmit --pretty false",
    "db:push": "drizzle-kit push",
    "db:migrate": "drizzle-kit migrate",
    "db:seed:all": "node dist/scripts/seed-all.js",
    "db:seed:coa": "node dist/scripts/seed-coa.js",
    "gen:openapi": "node dist/scripts/generate-openapi.js",
    "verify:routes": "node dist/scripts/verify-routes.js",
    "verify:schemas": "node dist/scripts/verify-schemas.js",
    "verify:seeds": "node dist/scripts/verify-seeds.js",
    "verify:env": "node dist/scripts/verify-env.js",
    "verify:auth": "node dist/scripts/verify-auth.js",
    "verify:jobs": "node dist/scripts/verify-jobs.js",
    "verify:cfg": "node dist/scripts/verify-config.js",
    "verify:all": "node dist/scripts/verify-all.js",
    "test:smoke": "node dist/scripts/smoke-test.js",
    "report:manifest": "node dist/scripts/export-manifest.js",
    "report:parity": "node dist/scripts/export-parity-report.js",
    "package:backend": "node dist/scripts/package-backend.js"
  }
}
tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "rootDir": "src",
    "outDir": "dist",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "strict": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "baseUrl": "src"
  },
  "include": ["src", "scripts"]
}
.env.example (list all used keys; no placeholders omitted)
NODE_ENV=production
PORT=8080
DATABASE_URL=postgres://user:pass@host:5432/peergos
SESSION_SECRET=change_me
CORS_ORIGIN=https://app.peergos.ae
JWT_ISSUER=peergos
JWT_AUDIENCE=peergos-users
JWT_EXPIRES_IN=1d
RATE_LIMIT_WINDOW_MS=60000
RATE_LIMIT_MAX=200
NOTIFY_PROVIDER=mock
G42_ENDPOINT=
INJAZAT_ENDPOINT=
POS_PROVIDER_URL=
BANK_PROVIDER_URL=
FTA_MODE=sandbox
3) Server & health
src/server.ts: Express app, JSON, CORS (CORS_ORIGIN comma-sep), cookie/session if used, rate limit.
Endpoints:
GET /health → {status:'ok'}
GET /admin/coa/count → {count:number} (must be > 0 after seed)
Preserve all existing API routes exactly (paths & methods unchanged).
4) Database + seeds (must be full)
Bring all migrations.
scripts/seed-all.ts compiles to dist/scripts/seed-all.js; it must call COA seeder and any other mandatory seeders.
COA seeder must insert the full UAE Chart of Accounts dataset used in main system. Log inserted count.
Add fixture verification queries for critical reference tables.
5) Deep verification suite (build these minimal scripts; OK to introspect code)
Under src/scripts/ create:
generate-openapi.ts
Build OpenAPI from route metadata or scan src/routes to list all endpoints (method, path, controller).
verify-routes.ts
Compare discovered routes against main repo route list (copy the main list into a JSON within this project as REFERENCE_ROUTES.json during extraction). Fail if any missing or extra.
verify-schemas.ts
Introspect ORM models/migrations; compare against REFERENCE_SCHEMAS.json (exported from main repo). Fail on diffs (tables, columns, enums, indexes).
verify-seeds.ts
Run COA and mandatory seeders in a temp DB schema; assert expected row counts (e.g., COA > 150 or exact expected). Fail if mismatch.
verify-env.ts
Parse code for process.env.* usage; ensure every key appears in .env.example. Fail if any missing.
verify-auth.ts
Ensure auth middlewares & permission checks exist on all protected routes (role matrix vs REFERENCE_PERMISSIONS.json). Fail on gaps.
verify-jobs.ts
Validate background jobs/cron/queues exist and are registered (names, schedules). Fail if any job found in reference but not present.
verify-config.ts
Compare critical config (rate limits, CORS, cookie flags, TLS settings, FTA mode, pagination defaults) with reference.
verify-all.ts
Runs all verifiers in sequence; returns non-zero exit code on any failure.
smoke-test.ts
Starts server, hits /health, exercises one login (if available with test creds), one protected endpoint, and /admin/coa/count. Exit non-zero on any failure.
export-manifest.ts
Output MANIFEST.json: version, timestamp, Node/TS versions, dependency list, routes list, DB models hash, seeds status (expected vs actual), health=200, counts.
export-parity-report.ts
Compose PARITY_REPORT.md with:
Route parity (match/mismatch list)
Schema parity (diff summary)
Seeds verification (COA count, other seeds)
Env coverage (missing keys list)
Auth/permissions matrix check
Background jobs table (present/missing)
Config parity summary
Smoke test results (HTTP codes)
Final verdict: PASS/FAIL
6) Build, run, and do not proceed if any check fails
Commands to execute (and print outputs):
npm ci
npm run typecheck

# DB setup
npm run db:push || npm run db:migrate

# Build
npm run build

# Seeds (full)
node dist/scripts/seed-all.js

# Generate docs & run verifications
node dist/scripts/generate-openapi.js
node dist/scripts/verify-all.js

# Start & smoke test
node dist/server.js & echo $! > /tmp/api.pid
sleep 2
curl -s -o /dev/null -w "HEALTH:%{http_code}\n" http://localhost:8080/health
npm run test:smoke || true
kill $(cat /tmp/api.pid) || true

# Reports
node dist/scripts/export-manifest.js
node dist/scripts/export-parity-report.js

# Print key lines
echo "TYPECHECK: OK"
echo "SEEDS: COA and mandatory seeds applied"
grep -E 'Final verdict|Route parity|Schema parity|COA count' PARITY_REPORT.md | head -n 50
Rule: If verify-all or test:smoke fails, STOP, fix the issue, re-run all steps. Only continue when PARITY_REPORT.md shows Final verdict: PASS.
7) Package only after PASS
Create a deterministic package with docs and reports:
TS=$(date +%Y%m%d-%H%M)
tar -czf "peergos-backend-$TS.tar.gz" \
  --exclude="node_modules" --exclude=".git" --exclude="*.map" --exclude="*.log" \
  dist package.json package-lock.json tsconfig.json .env.example \
  MANIFEST.json PARITY_REPORT.md README.md

ls -lh "peergos-backend-$TS.tar.gz"
tar -tzf "peergos-backend-$TS.tar.gz" | wc -l
Print:
PACKAGE: peergos-backend-$TS.tar.gz <size>
LOCATION: /home/runner/peergos-backend-prod/
First 30 lines of PARITY_REPORT.md.
8) Success criteria (must be true)
TYPECHECK: 0 errors
/health: HTTP 200
COA present: /admin/coa/count > 0 (or exact expected)
verify-all: PASS (no missing routes/models/seeds/env/auth/jobs)
PARITY_REPORT.md: Final verdict: PASS